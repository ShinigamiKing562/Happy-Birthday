/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/fish.js":
/*!*********************!*\
  !*** ./lib/fish.js ***!
  \*********************/
/***/ ((module) => {

eval("{class Fish{\r\n  constructor({mass,x,y,direction,pond}){\r\n    this.colors = [\r\n      [70,70,70],//black\r\n      [226, 79, 24],//orange\r\n      [255,245,45],//yellow\r\n      [253, 230, 230],//white\r\n    ];\r\n    this.baseColor= Math.floor(Math.random()*this.colors.length);\r\n    this.pond=pond;\r\n    this.counter=0;\r\n\r\n    this.mass= mass || 50;\r\n\r\n    this.segmentLength = 10;\r\n\r\n    this.ripple = false;\r\n\r\n    this.velx=0;\r\n    this.vely=0;\r\n    this.target=null;\r\n\r\n    this.targetDir=Math.PI/4+Math.PI/2;\r\n    //used to orient the fish on initialization\r\n    const radian= direction || Math.random()*Math.PI * 2;\r\n\r\n    //=POWER(F36/((5+INT(LN(F36)))*PI()),1/3)\r\n    const maxRadius = Math.cbrt(this.mass / ((5 + Math.floor(Math.log(this.mass))) * Math.PI));\r\n\r\n    //mouth init\r\n    this.mouth=new Mouth({\r\n      radius: maxRadius / 2\r\n    });\r\n\r\n    //head init\r\n    this.head=new Head({\r\n      radius: maxRadius,\r\n      radian:radian,\r\n      prevPart: this.mouth,\r\n      x:x,\r\n      y:y\r\n    });\r\n\r\n    const modifier = (this.head.mass + this.mouth.mass) / this.mass;\r\n\r\n    this.parts = [];\r\n    this.parts.push(\r\n      new Part({\r\n        radius:maxRadius,\r\n        prevPart:this.head,\r\n        segmentLength:this.head.radius * 10,\r\n        fish:this\r\n      })\r\n    );\r\n    this.head.setNextPart(this.parts[0]);\r\n    let part;\r\n    for(let i = 1;this.parts[i - 1].radius > 0.5;i++){\r\n      part=new Part({\r\n        radius:this.parts[i - 1].radius - modifier,\r\n        prevPart:this.parts[i - 1],\r\n        segmentLength:this.segmentLength,\r\n        fish:this\r\n      });\r\n      this.parts[i - 1].setNextPart(part);\r\n      this.parts.push(part);\r\n    }\r\n    this.tail = new Tail(this, this.head.radius);\r\n    this.fins = new Fins(this, this.head.radius);\r\n  }\r\n  updateTargetDir(x,y){\r\n    if(!this.target)\r\n      return this.target=null;\r\n    const xdiff = this.target.x - this.mouth.x;\r\n    const ydiff = this.target.y - this.mouth.y;\r\n    if(xdiff === 0){\r\n      if(ydiff < 0)\r\n        this.targetDir = Math.PI * 3 / 2;\r\n      this.targetDir = Math.PI / 2;\r\n    }\r\n    const radian = Math.atan(ydiff / xdiff);\r\n    if(xdiff > 0)\r\n        this.targetDir=radian\r\n    else\r\n        this.targetDir=-Math.PI+radian;\r\n  }\r\n  foodNotify(food){\r\n    if(this.target && food.getDistance(this.mouth.x,this.mouth.y) <\r\n      this.target.getDistance(this.mouth.x,this.mouth.y))\r\n      this.target=food;\r\n    else if(!this.target)\r\n      this.target=food;\r\n\r\n  }\r\n  feed(x){\r\n    this.ripple = true;\r\n    this.updateMass(this.mass+x);\r\n    this.change();\r\n  }\r\n  change(){\r\n    this.counter++;\r\n    if(this.counter > 1){\r\n      this.counter = 0;\r\n      const rand = Math.random() * 3;\r\n      if(rand < 1)\r\n        this.tail.change();\r\n      else if(rand < 2)\r\n        this.fins.change();\r\n      else{\r\n        this.tail.change();\r\n        this.fins.change();\r\n      }\r\n    }\r\n  }\r\n  updateMass(mass){\r\n    // return;\r\n    this.mass= mass > 50 ? mass : 50;\r\n\r\n    const maxRadius = Math.cbrt(this.mass / ((5 + Math.floor(Math.log(this.mass))) * Math.PI));\r\n\r\n    //mouth update\r\n    this.mouth.updateRadius(maxRadius/2);\r\n\r\n    //head update\r\n    this.head.updateRadius(maxRadius);\r\n\r\n    this.parts[0].updateRadius(maxRadius,this);\r\n\r\n    const modifier = (this.head.mass + this.mouth.mass) / this.mass;\r\n    let part;\r\n    for(let i = 1;this.parts[i - 1].radius > 0.5;i++){\r\n      if(this.parts[i]){\r\n        this.parts[i].updateRadius(this.parts[i - 1].radius - modifier,this);\r\n      }\r\n      else{\r\n        part=new Part({\r\n          radius:this.parts[i - 1].radius - modifier,\r\n          prevPart:this.parts[i - 1],\r\n          segmentLength:this.segmentLength,\r\n          fish:this\r\n        });\r\n        this.parts[i - 1].setNextPart(part);\r\n        this.parts.push(part);\r\n      }\r\n    }\r\n    this.tail.updateRadius(this.head.radius);\r\n    this.fins.updateRadius(this.head.radius);\r\n  }\r\n  render(ctx){\r\n\r\n    //find target and calculate direction\r\n    if(!this.target){\r\n      this.target=this.pond.getClosestFood(this.mouth.x,this.mouth.y);\r\n      if(!this.target)\r\n        this.target=this.pond.getSpot();\r\n    }\r\n    else{\r\n      if(this.target.value === 0){\r\n        let tempTarget = this.pond.getClosestFood();\r\n        if(tempTarget)\r\n          this.target=tempTarget;\r\n      }\r\n      else if(this.target.value < 0){\r\n        this.target=this.pond.getClosestFood();\r\n        if(this.target === null)\r\n          this.target=this.pond.getSpot(this.mouth.x,this.mouth.y);\r\n      }\r\n    }\r\n    this.updateTargetDir();\r\n\r\n    //begin calculating movement from all parts\r\n    this.newvelx=0;\r\n    this.newvely=0;\r\n    this.parts[0].act(this);\r\n    this.velx *=0.97;\r\n    this.vely *=0.97;\r\n\r\n    //move fish based on net movement and tail movement\r\n    this.move(this.newvelx+this.velx,this.newvely+this.vely);\r\n\r\n    //checks mouth for food\r\n    this.pond.bite(this.mouth.x,this.mouth.y,this.mouth.radius,this);\r\n\r\n    //begin drawing\r\n    this.drawFish(ctx);\r\n\r\n    if(this.ripple){\r\n      this.pond.ripple(this.mouth.x,this.mouth.y,this.head.radius*10);\r\n      // this.rippleCounter = 5;\r\n    }\r\n    this.ripple = false;\r\n  }\r\n  drawFish(ctx){\r\n    this.fins.render(ctx);\r\n\r\n    ctx.fillStyle=`rgb(${this.colors[this.baseColor][0]},${this.colors[this.baseColor][1]},${this.colors[this.baseColor][2]})`;\r\n\r\n    //draw body\r\n    ctx.beginPath();\r\n    ctx.moveTo(...this.head.getPoint(this.head.radius*8,Math.PI/2));\r\n    let i;\r\n    for(i = 0;i < this.parts.length - 1;i++)\r\n      ctx.lineTo(...this.parts[i].getPoint(this.parts[i].radius*8,Math.PI/2));\r\n    ctx.lineTo(...this.parts[this.parts.length - 1].getPoint(0,0));\r\n    for(i = this.parts.length - 2;i >-1;i--)\r\n      ctx.lineTo(...this.parts[i].getPoint(this.parts[i].radius*8,-Math.PI/2));\r\n    ctx.lineTo(...this.head.getPoint(this.head.radius*8,-Math.PI/2));\r\n    ctx.fill();\r\n    ctx.closePath();\r\n\r\n    //draw head\r\n    ctx.beginPath();\r\n    ctx.moveTo(...this.head.getPoint(this.head.radius*8,Math.PI/2+.1));\r\n    ctx.lineTo(...this.head.getPoint(this.head.radius*9,Math.PI/3));\r\n    ctx.lineTo(...this.head.getPoint(this.head.radius*10.5,Math.PI/5));\r\n    ctx.lineTo(...this.head.getPoint(this.head.radius*11,Math.PI/6));\r\n    ctx.quadraticCurveTo(...this.head.getPoint(this.head.radius*20,0),\r\n      ...this.head.getPoint(this.head.radius*11,-Math.PI/6));\r\n    ctx.lineTo(...this.head.getPoint(this.head.radius*10.5,-Math.PI/5));\r\n    ctx.lineTo(...this.head.getPoint(this.head.radius*9,-Math.PI/3));\r\n    ctx.lineTo(...this.head.getPoint(this.head.radius*8,-Math.PI/2-.1));\r\n    ctx.fill();\r\n    ctx.closePath();\r\n\r\n    //draw tail\r\n    this.tail.render(ctx);\r\n\r\n    //draw dorsal\r\n    ctx.fillStyle=`rgb(${this.colors[this.baseColor][0]*.8},${this.colors[this.baseColor][1]*.8},${this.colors[this.baseColor][2]*.8})`;\r\n    ctx.beginPath();\r\n    ctx.moveTo(...this.parts[Math.floor(this.parts.length / 5)].getPoint(0,0));\r\n    // right side\r\n    for(i = Math.floor(this.parts.length / 5)+1;i < Math.floor(this.parts.length*3/4) + 1;i++)\r\n      ctx.lineTo(...this.parts[i].getPoint(this.parts[i].radius*2,Math.PI/2));\r\n    // center\r\n    ctx.lineTo(...this.parts[Math.floor(this.parts.length*3/4)].getPoint(0,0));\r\n    // left side\r\n    for(i = Math.floor(this.parts.length*3/4) + 1;i > Math.floor(this.parts.length / 5);i--)\r\n      ctx.lineTo(...this.parts[i].getPoint(this.parts[i].radius*2,-Math.PI/2));\r\n    ctx.fill();\r\n    ctx.closePath();\r\n  }\r\n  move(x,y){\r\n    this.head.move(x,y);\r\n  }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\nclass Mouth{\r\n  constructor({radius}){\r\n    this.x=null;\r\n    this.y=null;\r\n\r\n    this.radius = radius;\r\n    this.mass = Math.PI * 4 / 3 * Math.pow(this.radius, 3);\r\n  }\r\n  updateRadius(radius){\r\n    this.radius = radius;\r\n    this.mass = Math.PI * 4 / 3 * Math.pow(this.radius, 3);\r\n  }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\nclass Head{\r\n  constructor({radius,radian,prevPart,x,y}){\r\n    this.x=x;\r\n    this.y=y;\r\n    this.radian = radian;\r\n\r\n    this.radius = radius;\r\n    this.mass = Math.PI * 4 / 3 * Math.pow(this.radius, 3);\r\n\r\n    this.prevPart=prevPart;\r\n    this.prevPart.x=this.x + this.radius*1.3 * 10 * Math.cos(this.radian);\r\n    this.prevPart.y=this.y + this.radius*1.3 * 10 * Math.sin(this.radian);\r\n\r\n    this.nextPart=null;\r\n  }\r\n  setNextPart(part){\r\n    if(this.nextPart === null){\r\n      this.nextPart = part;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  updateRadius(radius){\r\n      this.radius = radius;\r\n      this.mass = Math.PI * 4 / 3 * Math.pow(this.radius, 3);\r\n    // this.nextPart.segmentLength=this.radius;\r\n  }\r\n  getPoint(radius,angle){\r\n    return [\r\n      this.x+radius*Math.cos(angle+this.radian),\r\n      this.y+radius*Math.sin(angle+this.radian)\r\n    ];\r\n  }\r\n  move(x,y){\r\n    this.nextPart.move(x,y);\r\n    this.radian = this.nextPart.radian;\r\n    this.x=this.nextPart.x + this.radius * 10 * Math.cos(this.radian);\r\n    this.y=this.nextPart.y + this.radius * 10 * Math.sin(this.radian);\r\n    this.prevPart.x=this.x + this.radius*1.3 * 10 * Math.cos(this.radian);\r\n    this.prevPart.y=this.y + this.radius*1.3 * 10 * Math.sin(this.radian);\r\n  }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\nclass Part{\r\n  constructor({radius,prevPart,segmentLength,fish}){\r\n    //one time sets\r\n    this.prevPart=prevPart;\r\n    this.segmentLength=segmentLength;\r\n    this.nextPart = null;\r\n    this.commitMove = 0;\r\n    this.dirCount=0;\r\n    this.x = this.prevPart.x + this.segmentLength * Math.cos(this.prevPart.radian + Math.PI);\r\n    this.y = this.prevPart.y + this.segmentLength * Math.sin(this.prevPart.radian + Math.PI);\r\n    this.atTarget=null;\r\n\r\n    //set on mass change\r\n    this.radius = radius;\r\n    this.mass = Math.PI * 4 / 3 * Math.pow(this.radius, 3);\r\n    this.maxAngle=Math.PI/(Math.pow(Math.log(fish.mass),1.1));\r\n    this.maxAngle=this.radius*this.radius/this.mass * this.maxAngle;\r\n    this.moveAngle = this.maxAngle / 3;\r\n    this.commitMax=3+Math.floor(Math.pow(fish.mass,1/2.5));\r\n\r\n    //run at the end of init\r\n    this.updateRadian();\r\n  }\r\n  updateRadian(){\r\n    const xdiff = this.prevPart.x - this.x;\r\n    const ydiff = this.prevPart.y - this.y;\r\n    if(xdiff === 0){\r\n      if(ydiff < 0)\r\n        this.radian = Math.PI * 3 / 2;\r\n      this.radian = Math.PI / 2;\r\n    }\r\n    const radian = Math.atan(ydiff / xdiff);\r\n    if(xdiff > 0)\r\n        this.radian=radian\r\n    else\r\n        this.radian=-Math.PI+radian;\r\n  }\r\n  setNextPart(part){\r\n    if(this.nextPart === null){\r\n      this.nextPart = part;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  updateRadius(radius,fish){\r\n    this.radius = radius;\r\n    this.mass = Math.PI * 4 / 3 * Math.pow(this.radius, 3);\r\n    this.maxAngle=Math.PI/(Math.pow(Math.log(fish.mass),1));\r\n    this.maxAngle=this.radius*this.radius/this.mass * this.maxAngle;\r\n    this.moveAngle = this.maxAngle / 3;\r\n    this.commitMax=1+Math.floor(Math.pow(fish.mass,1/2.7));\r\n    this.updateRadian();\r\n  }\r\n  rotate(angle){\r\n    const s = Math.sin(angle);\r\n    const c = Math.cos(angle);\r\n\r\n    const dx = this.x - this.prevPart.x;\r\n    const dy = this.y - this.prevPart.y;\r\n\r\n    this.x=dx*c-dy*s + this.prevPart.x;\r\n    this.y=dx*s+dy*c + this.prevPart.y;\r\n  }\r\n  act(fish){\r\n    let oldx = this.x;\r\n    let oldy = this.y;\r\n    this.updateRadian();\r\n    let angleDiff = this.radian - this.prevPart.radian;\r\n    if(angleDiff > Math.PI)\r\n      angleDiff -= Math.PI * 2;\r\n    else if(angleDiff < -Math.PI)\r\n      angleDiff += Math.PI * 2;\r\n\r\n    //pull self to prevPart\r\n    if(Math.abs(angleDiff) > this.maxAngle){//angle correction\r\n      this.commitMove = 0;\r\n      if(angleDiff > 0){\r\n        if(angleDiff - this.maxAngle > this.moveAngle * 2){\r\n          const rad = this.prevPart.radian + Math.PI + this.maxAngle*0.8;\r\n          this.x = this.prevPart.x + this.segmentLength * Math.cos(rad);\r\n          this.y = this.prevPart.y + this.segmentLength * Math.sin(rad);\r\n        }\r\n        else{\r\n          this.x = this.prevPart.x + this.segmentLength * Math.cos(this.radian + Math.PI);\r\n          this.y = this.prevPart.y + this.segmentLength * Math.sin(this.radian + Math.PI);\r\n          this.rotate(-this.moveAngle);\r\n        }\r\n      }\r\n      else{\r\n        if(angleDiff + this.maxAngle < -this.moveAngle * 2){\r\n          const rad = this.prevPart.radian + Math.PI - this.maxAngle*0.8;\r\n          this.x = this.prevPart.x + this.segmentLength * Math.cos(rad);\r\n          this.y = this.prevPart.y + this.segmentLength * Math.sin(rad);\r\n        }\r\n        else{\r\n          this.x = this.prevPart.x + this.segmentLength * Math.cos(this.radian + Math.PI);\r\n          this.y = this.prevPart.y + this.segmentLength * Math.sin(this.radian + Math.PI);\r\n          this.rotate(this.moveAngle);\r\n        }\r\n      }\r\n    }\r\n    //movement\r\n    else{\r\n      //pulls self to prevPart\r\n      this.x = this.prevPart.x + this.segmentLength * Math.cos(this.radian + Math.PI);\r\n      this.y = this.prevPart.y + this.segmentLength * Math.sin(this.radian + Math.PI);\r\n      angleDiff = this.radian - fish.targetDir;\r\n      if(angleDiff > Math.PI)\r\n        angleDiff -= Math.PI * 2;\r\n      else if(angleDiff < -Math.PI)\r\n        angleDiff += Math.PI * 2;\r\n\r\n      if(this.commitMove < 0){\r\n        this.rotate(-this.moveAngle);\r\n        this.commitMove += 1;\r\n      }\r\n      else if(this.commitMove > 0){\r\n        this.rotate(this.moveAngle);\r\n        this.commitMove -= 1;\r\n      }\r\n      else if(angleDiff > 0){\r\n        if(angleDiff < 0.1){\r\n          this.commitMove = -this.commitMax;\r\n        }\r\n        this.rotate(-this.moveAngle);\r\n        if(this.dirCount > 2*this.commitMax){\r\n          this.commitMove = 1+Math.floor(this.commitMax/3);\r\n          this.dirCount=0;\r\n        }\r\n        else if(this.dirCount > 0)\r\n          this.dirCount++;\r\n        else {\r\n          this.dirCount=1;\r\n        }\r\n      }\r\n      else{\r\n        if(angleDiff > -0.1){\r\n          this.commitMove = this.commitMax;\r\n        }\r\n        this.rotate(this.moveAngle);\r\n        if(this.dirCount < -2*this.commitMax){\r\n          this.commitMove = -1-Math.floor(this.commitMax/3);\r\n          this.dirCount=0;\r\n        }\r\n        else if(this.dirCount < 0)\r\n          this.dirCount--;\r\n        else {\r\n          this.dirCount=-1;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.updateRadian();\r\n\r\n    if(this.nextPart){\r\n      const ratio = this.mass / fish.mass;\r\n      fish.newvelx += (oldx - this.x) * ratio;\r\n      fish.newvely += (oldy - this.y) * ratio;\r\n      this.nextPart.act(fish);\r\n    }\r\n    else{\r\n      let distMod = 0;\r\n      if(fish.target && fish.target.getDistance(fish.mouth.x,fish.mouth.y) > 300){\r\n        distMod = 5/fish.mass*(1 - 50/fish.target.getDistance(fish.mouth.x,fish.mouth.y));\r\n      }\r\n\r\n      let dir=fish.parts[0].radian-fish.targetDir;\r\n      if(dir > Math.PI)\r\n        dir -= Math.PI * 2;\r\n      else if(dir < -Math.PI)\r\n        dir += Math.PI * 2;\r\n\r\n      //orient fish\r\n      const ratio = this.mass / fish.mass;\r\n      const xdiff=oldx - this.x;\r\n      const ydiff=oldy - this.y;\r\n      fish.newvelx += xdiff * ratio;\r\n      fish.newvely += ydiff * ratio;\r\n      //move forward\r\n      this.atTarget=Math.pow((1-2*Math.abs(dir)/Math.PI),3) + distMod*5;\r\n      const movDist = Math.sqrt(xdiff * xdiff +ydiff*ydiff);\r\n      fish.velx += movDist * Math.cos(fish.parts[0].radian) / 10*this.atTarget;\r\n      fish.vely += movDist * Math.sin(fish.parts[0].radian) / 10*this.atTarget;\r\n    }\r\n  }\r\n  move(x,y){\r\n    this.x += x;\r\n    this.y += y;\r\n\r\n    if(this.nextPart)\r\n      this.nextPart.move(x,y);\r\n  }\r\n  getPoint(radius,angle){\r\n    return [\r\n      this.x+radius*Math.cos(angle+this.radian),\r\n      this.y+radius*Math.sin(angle+this.radian)\r\n    ];\r\n  }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\nclass Tail{\r\n  constructor(fish,radius){\r\n    this.changeCount = 0;\r\n    this.fish = fish;\r\n    this.pieces=[[],[],[],[],[]];\r\n    this.radius = radius;\r\n    this.pieceLength=this.radius*2;\r\n    this.tip = fish.parts[this.fish.parts.length - 1];\r\n    this.maxAngle = this.tip.maxAngle;\r\n\r\n    for(let i = 0;i <3;i++)\r\n      this.pieces[2].push(new TailPiece(this,this.pieces[2][i-1],0));\r\n    for(let i = 0;i < 5;i++)\r\n      this.pieces[1].push(new TailPiece(this,this.pieces[1][i-1],1));\r\n    for(let i = 0;i < 8;i++)\r\n      this.pieces[0].push(new TailPiece(this,this.pieces[0][i-1],2));\r\n    for(let i = 0;i < 5;i++)\r\n      this.pieces[3].push(new TailPiece(this,this.pieces[3][i-1],-1));\r\n    for(let i = 0;i < 8;i++)\r\n      this.pieces[4].push(new TailPiece(this,this.pieces[4][i-1],-2));\r\n  }\r\n  change(){\r\n    const rand = Math.random() * 3;\r\n    if(rand < 1)\r\n      this.pieces[2].push(new TailPiece(this,this.pieces[2][this.pieces[2].length-1],0));\r\n    else if(rand < 2){\r\n      this.pieces[1].push(new TailPiece(this,this.pieces[1][this.pieces[1].length-1],1));\r\n      this.pieces[3].push(new TailPiece(this,this.pieces[3][this.pieces[3].length-1],-1));\r\n    }\r\n    else{\r\n      this.pieces[0].push(new TailPiece(this,this.pieces[0][this.pieces[0].length-1],2));\r\n      this.pieces[4].push(new TailPiece(this,this.pieces[4][this.pieces[4].length-1],-2));\r\n    }\r\n  }\r\n  updateRadius(radius){\r\n    //do stuff to tailpieces\r\n    this.radius = radius;\r\n    this.pieceLength=this.radius*2;\r\n    this.tip = this.fish.parts[this.fish.parts.length - 1];\r\n    this.maxAngle = this.tip.maxAngle;\r\n    for(let i = 0;i < 5;i++)\r\n      this.pieces[i][0].prevPart=this.tip;\r\n  }\r\n  act(){\r\n    this.tip = this.fish.parts[this.fish.parts.length - 1];\r\n    for(let i = 0;i < this.pieces[2].length;i++)\r\n      this.pieces[2][i].act(this);\r\n    for(let i = 0;i < this.pieces[1].length;i++)\r\n      this.pieces[1][i].act(this);\r\n    for(let i = 0;i < this.pieces[0].length;i++)\r\n      this.pieces[0][i].act(this);\r\n    for(let i = 0;i < this.pieces[3].length;i++)\r\n      this.pieces[3][i].act(this);\r\n    for(let i = 0;i < this.pieces[4].length;i++)\r\n      this.pieces[4][i].act(this);\r\n  }\r\n  render(ctx){\r\n    this.act();\r\n    ctx.fillStyle=`rgba(${this.fish.colors[this.fish.baseColor][0]},${this.fish.colors[this.fish.baseColor][1]},${this.fish.colors[this.fish.baseColor][2]},.4)`;\r\n\r\n    for(let j = 0;j < this.pieces.length - 1;j++){\r\n      ctx.beginPath();\r\n      ctx.moveTo(...this.tip.getPoint(0,0));\r\n      for(let i = 0;i < this.pieces[j].length;i++)\r\n        ctx.lineTo(this.pieces[j][i].x,this.pieces[j][i].y);\r\n      for(let i = this.pieces[j+1].length-1;i > -1;i--)\r\n        ctx.lineTo(this.pieces[j+1][i].x,this.pieces[j+1][i].y);\r\n      ctx.fill();\r\n      ctx.closePath();\r\n    }\r\n\r\n    ctx.strokeStyle=`rgba(${this.fish.colors[this.fish.baseColor][0]*.8},${this.fish.colors[this.fish.baseColor][1]*.8},${this.fish.colors[this.fish.baseColor][2]*.8},.3)`;\r\n    ctx.lineWidth=1;\r\n    for(let j = 0;j < this.pieces.length;j++){\r\n      ctx.beginPath();\r\n      ctx.moveTo(...this.tip.getPoint(0,0));\r\n      for(let i = 0;i < this.pieces[j].length;i++)\r\n        ctx.lineTo(this.pieces[j][i].x,this.pieces[j][i].y);\r\n      ctx.stroke();\r\n      ctx.closePath();\r\n    }\r\n  }\r\n}\r\nclass TailPiece{\r\n  constructor(tail,prevPart,offset){\r\n    this.prevPart=prevPart;\r\n    this.offset=offset;\r\n    this.velx=0;\r\n    this.vely=0;\r\n    this.x=null;\r\n    this.y=null;\r\n\r\n    if(!this.prevPart)\r\n      this.prevPart = tail.tip;\r\n    this.radian=this.prevPart.radian;\r\n    this.maxAngle = this.prevPart.maxAngle;\r\n    //pull self to tail\r\n    [this.x,this.y]=this.prevPart.getPoint(tail.pieceLength,this.prevPart.radian+Math.PI);\r\n  }\r\n  act(tail){\r\n    let oldx = this.x;\r\n    let oldy = this.y;\r\n    this.x +=this.velx;\r\n    this.y += this.vely;\r\n    this.updateRadian();\r\n    let angleDiff = this.radian+this.offset/3 - this.prevPart.radian;\r\n    if(angleDiff > Math.PI)\r\n      angleDiff -= Math.PI * 2;\r\n    else if(angleDiff < -Math.PI)\r\n      angleDiff += Math.PI * 2;\r\n\r\n    //pull self to prevPart\r\n    if(Math.abs(angleDiff) > tail.maxAngle){//angle correction\r\n      if(angleDiff > 0){\r\n        if(angleDiff - tail.maxAngle > tail.maxAngle/2){\r\n          const rad = this.prevPart.radian + Math.PI + tail.maxAngle;\r\n          this.x = this.prevPart.x + tail.pieceLength * Math.cos(rad);\r\n          this.y = this.prevPart.y + tail.pieceLength * Math.sin(rad);\r\n        }\r\n        else{\r\n          this.x = this.prevPart.x + tail.pieceLength * Math.cos(this.radian + Math.PI);\r\n          this.y = this.prevPart.y + tail.pieceLength * Math.sin(this.radian + Math.PI);\r\n          // this.rotate(-tail.maxAngle/5);\r\n        }\r\n      }\r\n      else{\r\n        if(angleDiff + tail.maxAngle < -tail.maxAngle/2){\r\n          const rad = this.prevPart.radian + Math.PI - tail.maxAngle;\r\n          this.x = this.prevPart.x + tail.pieceLength * Math.cos(rad);\r\n          this.y = this.prevPart.y + tail.pieceLength * Math.sin(rad);\r\n        }\r\n        else{\r\n          this.x = this.prevPart.x + tail.pieceLength * Math.cos(this.radian + Math.PI);\r\n          this.y = this.prevPart.y + tail.pieceLength * Math.sin(this.radian + Math.PI);\r\n          // this.rotate(tail.maxAngle/5);\r\n        }\r\n      }\r\n    }\r\n    else{\r\n      this.x = this.prevPart.x + tail.pieceLength * Math.cos(this.radian + Math.PI);\r\n      this.y = this.prevPart.y + tail.pieceLength * Math.sin(this.radian + Math.PI);\r\n    }\r\n    this.velx = (this.velx + this.x - oldx)/5;\r\n    this.vely = (this.vely + this.y - oldy)/5;\r\n  }\r\n  rotate(angle){\r\n    const s = Math.sin(angle);\r\n    const c = Math.cos(angle);\r\n\r\n    const dx = this.x - this.prevPart.x;\r\n    const dy = this.y - this.prevPart.y;\r\n\r\n    this.x=dx*c-dy*s + this.prevPart.x;\r\n    this.y=dx*s+dy*c + this.prevPart.y;\r\n  }\r\n  updateRadian(){\r\n    const xdiff = this.prevPart.x - this.x;\r\n    const ydiff = this.prevPart.y - this.y;\r\n    if(xdiff === 0){\r\n      if(ydiff < 0)\r\n        this.radian = Math.PI * 3 / 2;\r\n      this.radian = Math.PI / 2;\r\n    }\r\n    const radian = Math.atan(ydiff / xdiff);\r\n    if(xdiff > 0)\r\n        this.radian=radian\r\n    else\r\n        this.radian=-Math.PI+radian;\r\n  }\r\n  getPoint(radius,angle){\r\n    return [\r\n      this.x+radius*Math.cos(angle+this.radian),\r\n      this.y+radius*Math.sin(angle+this.radian)\r\n    ];\r\n  }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n\r\nclass Fins{\r\n  constructor(fish,radius){\r\n    this.fish = fish;\r\n    this.fins=[\r\n      new Fin(fish,1,0,radius),\r\n      new Fin(fish,-1,0,radius),\r\n      new Fin(fish,1,.3,radius),\r\n      new Fin(fish,-1,.3,radius)\r\n    ]\r\n    this.radius = radius;\r\n    this.tip = fish.parts[this.fish.parts.length - 1];\r\n    this.maxAngle = this.tip.maxAngle;\r\n  }\r\n  updateRadius(radius){\r\n    for(let i = 0;i < this.fins.length;i++)\r\n      this.fins[i].updateRadius(radius);\r\n  }\r\n  change(){\r\n    const rand = Math.random()*2;\r\n    if(rand > 1){\r\n      this.fins[0].change(rand/2);\r\n      this.fins[1].change(rand/2);\r\n    }\r\n    else{\r\n      this.fins[2].change(rand/2);\r\n      this.fins[3].change(rand/2);\r\n    }\r\n  }\r\n  act(){\r\n    for(let i = 0;i < this.fins.length;i++)\r\n      this.fins[i].act();\r\n  }\r\n  render(ctx){\r\n    this.act();\r\n\r\n    for(let i = 0;i < this.fins.length;i++)\r\n      this.fins[i].render(ctx);\r\n  }\r\n}\r\nclass Fin{\r\n  constructor(fish,side,ratio,radius){//1 is left, -1 is right\r\n    this.fish=fish;\r\n    this.side= side;\r\n    this.ratio = ratio;\r\n    this.radius = radius;\r\n    this.part = fish.parts[Math.floor(fish.parts.length * ratio)];\r\n    this.pieceLength = this.radius * 3+1;\r\n    this.pieces = [\r\n      [new FinPiece(this,undefined,this.side,0)],\r\n      [new FinPiece(this,undefined,this.side,1)],\r\n      [new FinPiece(this,undefined,this.side,2)],\r\n      [new FinPiece(this,undefined,this.side,3)],\r\n      [new FinPiece(this,undefined,this.side,4)],\r\n      [new FinPiece(this,undefined,this.side,5)],\r\n      [new FinPiece(this,undefined,this.side,6)],\r\n    ];\r\n\r\n    for(let i = 0;i < 7;i++)\r\n      for(let j = 0;j < 5-i/2;j++)\r\n        this.pieces[i].push(new FinPiece(this,this.pieces[i][j],this.side,i));\r\n  }\r\n  updateRadius(radius){\r\n    this.radius = radius;\r\n    this.pieceLength = this.radius * 3+1;\r\n    this.part = this.fish.parts[Math.floor(this.fish.parts.length * this.ratio)];\r\n  }\r\n  change(rand){\r\n    const idx = Math.floor(rand * this.pieces.length);\r\n    const lastPiece = this.pieces[idx][this.pieces[idx].length - 1];\r\n    this.pieces[idx].push(\r\n      new FinPiece(this,lastPiece,this.side,idx)\r\n    );\r\n  }\r\n  act(){\r\n    for(let i = 0;i < this.pieces.length;i++)\r\n      for(let j = 0;j < this.pieces[i].length;j++)\r\n        this.pieces[i][j].act();\r\n  }\r\n  render(ctx){\r\n    ctx.fillStyle=`rgba(${this.fish.colors[this.fish.baseColor][0]},${this.fish.colors[this.fish.baseColor][1]},${this.fish.colors[this.fish.baseColor][2]},.4)`;\r\n\r\n    for(let j = 0;j < this.pieces.length - 1;j++){\r\n      ctx.beginPath();\r\n      ctx.moveTo(this.pieces[j][0].x,this.pieces[j][0].y);\r\n      for(let i = 1;i < this.pieces[j].length;i++)\r\n        ctx.lineTo(this.pieces[j][i].x,this.pieces[j][i].y);\r\n      for(let i = this.pieces[j+1].length-1;i > -1;i--)\r\n        ctx.lineTo(this.pieces[j+1][i].x,this.pieces[j+1][i].y);\r\n      ctx.fill();\r\n      ctx.closePath();\r\n    }\r\n\r\n    ctx.strokeStyle=`rgba(${this.fish.colors[this.fish.baseColor][0]*.8},${this.fish.colors[this.fish.baseColor][1]*.8},${this.fish.colors[this.fish.baseColor][2]*.8},.2)`;\r\n    ctx.lineWidth=1;\r\n    for(let j = 0;j < this.pieces.length;j++){\r\n      ctx.beginPath();\r\n      ctx.moveTo(this.pieces[j][0].x,this.pieces[j][0].y);\r\n      for(let i = 1;i < this.pieces[j].length;i++)\r\n        ctx.lineTo(this.pieces[j][i].x,this.pieces[j][i].y);\r\n      ctx.stroke();\r\n      ctx.closePath();\r\n    }\r\n\r\n    // ctx.beginPath();\r\n    // ctx.arc(this.pieces[3].x,this.pieces[3].y,5,0,2*Math.PI);\r\n    // ctx.fill();\r\n    // ctx.closePath();\r\n  }\r\n}\r\nclass FinPiece{\r\n  constructor(fin,prevPart,side,bias){\r\n    this.fin = fin;\r\n    this.prevPart = prevPart;\r\n    this.side = side;\r\n    this.finOffset=-this.side * ((1 - this.fin.ratio) * .3 - 5*this.fin.ratio);\r\n    this.bias = side * bias*Math.PI/8;\r\n    this.velx=0;\r\n    this.vely=0;\r\n\r\n    this.x=null;\r\n    this.y=null;\r\n    this.radian=null;\r\n    this.maxAngle=null;\r\n    if(!this.prevPart){\r\n      [this.x,this.y] = this.fin.part.getPoint(this.fin.part.radius*9,this.side*Math.PI/2+this.finOffset);\r\n      this.maxAngle = this.fin.part.maxAngle*this.fin.ratio;\r\n      this.radian = this.fin.part.radian + Math.PI / 2 * -this.side+this.finOffset/2+this.bias;\r\n    }\r\n    else{\r\n      this.maxAngle = this.prevPart.maxAngle;\r\n      this.radian=this.prevPart.radian;\r\n      [this.x,this.y] = this.prevPart.getPoint(this.fin.pieceLength,Math.PI);\r\n    }\r\n  }\r\n  act(){\r\n    if(!this.prevPart){\r\n      [this.x,this.y] = this.fin.part.getPoint(this.fin.part.radius*9,this.side*Math.PI/2+this.finOffset);\r\n      this.maxAngle = this.fin.part.maxAngle*this.fin.ratio;\r\n      this.radian = this.fin.part.radian + Math.PI / 2 * -this.side+this.finOffset/2+this.bias;\r\n    }\r\n    else{\r\n      this.maxAngle = this.prevPart.maxAngle;\r\n      let oldx = this.x;\r\n      let oldy = this.y;\r\n      this.x +=this.velx;\r\n      this.y += this.vely;\r\n      this.updateRadian();\r\n      let angleDiff = this.radian - this.prevPart.radian;\r\n      if(angleDiff > Math.PI)\r\n        angleDiff -= Math.PI * 2;\r\n      else if(angleDiff < -Math.PI)\r\n        angleDiff += Math.PI * 2;\r\n\r\n      //pull self to prevPart\r\n      if(angleDiff > 0){\r\n        if(angleDiff > this.maxAngle)\r\n          [this.x,this.y] = this.prevPart.getPoint(this.fin.pieceLength,Math.PI+this.maxAngle)\r\n        else{\r\n          this.x = this.prevPart.x + this.fin.pieceLength * Math.cos(this.radian + Math.PI);\r\n          this.y = this.prevPart.y + this.fin.pieceLength * Math.sin(this.radian + Math.PI);\r\n        }\r\n      }\r\n      else{\r\n        if(angleDiff < -this.maxAngle)\r\n          [this.x,this.y] = this.prevPart.getPoint(this.fin.pieceLength,Math.PI-this.maxAngle)\r\n        else{\r\n          this.x = this.prevPart.x + this.fin.pieceLength * Math.cos(this.radian + Math.PI);\r\n          this.y = this.prevPart.y + this.fin.pieceLength * Math.sin(this.radian + Math.PI);\r\n        }\r\n      }\r\n      this.velx = (this.velx + this.x - oldx)/5;\r\n      this.vely = (this.vely + this.y - oldy)/5;\r\n    }\r\n  }\r\n  updateRadian(){\r\n    const xdiff = this.prevPart.x - this.x;\r\n    const ydiff = this.prevPart.y - this.y;\r\n    if(xdiff === 0){\r\n      if(ydiff < 0)\r\n        this.radian = Math.PI * 3 / 2;\r\n      this.radian = Math.PI / 2;\r\n    }\r\n    const radian = Math.atan(ydiff / xdiff);\r\n    if(xdiff > 0)\r\n        this.radian=radian\r\n    else\r\n        this.radian=-Math.PI+radian;\r\n  }\r\n  getPoint(radius,angle){\r\n    return [\r\n      this.x+radius*Math.cos(angle+this.radian),\r\n      this.y+radius*Math.sin(angle+this.radian)\r\n    ];\r\n  }\r\n}\r\n// -----------------------------------------------------------------------------\r\n\r\nmodule.exports = Fish;\r\n\n\n//# sourceURL=webpack://happy-birthday/./lib/fish.js?\n}");

/***/ }),

/***/ "./lib/fish_pond.js":
/*!**************************!*\
  !*** ./lib/fish_pond.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const Fish = __webpack_require__(/*! ./fish */ \"./lib/fish.js\");\r\nconst Target = __webpack_require__(/*! ./target */ \"./lib/target.js\");\r\nconst Ripple = __webpack_require__(/*! ./ripple */ \"./lib/ripple.js\");\r\nconst Lotus = __webpack_require__(/*! ./lotus */ \"./lib/lotus.js\");\r\n\r\nclass FishPond {\r\n  constructor(window) {\r\n    this.var = 0.001;\r\n    this.instructions = true;\r\n    this.opacity = 0.8;\r\n    this.ops = this.opacity / 60;\r\n    this.maxFood = 100;\r\n    this.window = window;\r\n    this.height = this.window.innerHeight;\r\n    this.width = this.window.innerWidth;\r\n    this.vh = this.height / 100;\r\n    this.vw = this.width / 100;\r\n    this.spots = [new Target(0, 0, 0)];\r\n    for (let i = 1; i < 100; i++)\r\n      this.spots.push(new Target(0, 0, 0, this.spots[i - 1]));\r\n    this.spots[0].nextSpot = this.spots[this.spots.length - 1];\r\n\r\n    const halfh = this.height / 2;\r\n    const halfw = this.width / 2;\r\n    for (let i = 0; i < Math.floor(this.spots.length) / 2; i++) {\r\n      this.spots[i].x = halfw + Math.random() * halfw * Math.cos(i);\r\n      this.spots[i].y = halfh + Math.random() * halfh * Math.sin(i);\r\n    }\r\n    for (\r\n      let i = Math.floor(this.spots.length / 2);\r\n      i < this.spots.length;\r\n      i++\r\n    ) {\r\n      this.spots[i].x =\r\n        halfw + (halfw / 4 + (Math.random() * halfw) / 1.5) * Math.cos(-i);\r\n      this.spots[i].y =\r\n        halfh + (halfh / 3 + (Math.random() * halfh) / 2) * Math.sin(-i);\r\n    }\r\n\r\n    this.foods = [];\r\n    this.ripples = [];\r\n    this.fish = [];\r\n\r\n    let fishCount = 1 + (this.height * this.width) / 70000;\r\n    for (let i = 0; i < fishCount; i++) this.addFish();\r\n\r\n    this.lotusFormationMode = true;\r\n    this.formationTime = 0;\r\n\r\n    this.lotusImages = {\r\n      small: new Image(),\r\n      medium: new Image(),\r\n      large: new Image(),\r\n    };\r\n    this.lotusImages.small.src = \"assets/small-lotus.png\";\r\n    this.lotusImages.medium.src = \"assets/medium-lotus.png\";\r\n    this.lotusImages.large.src = \"assets/large-lotus.png\";\r\n\r\n    this.lotuses = [];\r\n\r\n    const spellPoints = this.getLetterLotusPositions();\r\n    for (let pt of spellPoints) {\r\n      const imgIndex = Math.floor(Math.random() * 3);\r\n      const image = [\r\n        this.lotusImages.small,\r\n        this.lotusImages.medium,\r\n        this.lotusImages.large,\r\n      ][imgIndex];\r\n      const size = this.vw * 10 + Math.random() * this.vw * 6;\r\n      const lotus = new Lotus(pt.x, pt.y, size, image, this);\r\n      lotus.targetX = pt.x;\r\n      lotus.targetY = pt.y;\r\n      this.lotuses.push(lotus);\r\n    }\r\n\r\n    this.birthdaySong = new Audio(\"assets/3005.m4a\");\r\n    this.songPlayed = false;\r\n    this.lotusStage = \"forming\";\r\n  }\r\n\r\n  start(canvas) {\r\n    const ctx = canvas.getContext(\"2d\");\r\n    const startAnimation = () => {\r\n      const h = this.height;\r\n      const w = this.width;\r\n      canvas.height = this.window.innerHeight;\r\n      canvas.width = this.window.innerWidth;\r\n      this.height = this.window.innerHeight;\r\n      this.width = this.window.innerWidth;\r\n      this.vh = this.height / 100;\r\n      this.vw = this.width / 100;\r\n\r\n      if (w !== this.width || h !== this.height) {\r\n        const halfh = this.height / 2;\r\n        const halfw = this.width / 2;\r\n        for (let i = 0; i < Math.floor(this.spots.length) / 2; i++) {\r\n          this.spots[i].x = halfw + Math.random() * halfw * Math.cos(i);\r\n          this.spots[i].y = halfh + Math.random() * halfh * Math.sin(i);\r\n        }\r\n        for (\r\n          let i = Math.floor(this.spots.length / 2);\r\n          i < this.spots.length;\r\n          i++\r\n        ) {\r\n          this.spots[i].x =\r\n            halfw + (halfw / 4 + (Math.random() * halfw) / 1.5) * Math.cos(-i);\r\n          this.spots[i].y =\r\n            halfh + (halfh / 3 + (Math.random() * halfh) / 2) * Math.sin(-i);\r\n        }\r\n      }\r\n\r\n      this.render(ctx);\r\n      setTimeout(startAnimation, 1000 / 30);\r\n    };\r\n    startAnimation();\r\n  }\r\n\r\n  render(ctx) {\r\n    ctx.fillStyle = \"#ffc983\";\r\n    ctx.fillRect(0, 0, this.width, this.height);\r\n    this.fish.sort((a, b) => b.mass - a.mass);\r\n    for (let fish of this.fish) fish.render(ctx);\r\n    for (let ripple of this.ripples) ripple.render(ctx);\r\n    for (let food of this.foods) food.render(ctx);\r\n\r\n    this.fontSize = Math.min(this.vh * 10, this.vw * 5);\r\n\r\n    if (this.opacity > 0) {\r\n      ctx.fillStyle = `rgba(50,50,50,${this.opacity})`;\r\n      ctx.fillRect(0, 0, this.width, this.height);\r\n      ctx.fillStyle = `rgba(255,255,255,${this.opacity * 1.25})`;\r\n      ctx.font = `${this.fontSize}px Arial`;\r\n      ctx.fillText(\r\n        \"Happy Birthday\",\r\n        this.width / 2 - this.fontSize * 3,\r\n        this.height / 2 - this.vh * 10\r\n      );\r\n      this.opacity -= this.ops;\r\n      if (!this.songPlayed && this.opacity < 0.01) {\r\n        this.birthdaySong.play();\r\n        this.songPlayed = true;\r\n      }\r\n    }\r\n\r\n    if (this.lotusStage === \"forming\" && this.opacity < 0.01) {\r\n      this.lotusStage = \"dispersed\";\r\n      for (let lotus of this.lotuses) {\r\n        lotus.targetX = Math.random() * this.width;\r\n        lotus.targetY = Math.random() * this.height;\r\n      }\r\n    }\r\n\r\n    for (const lotus of this.lotuses) lotus.render(ctx);\r\n  }\r\n\r\n  click(x, y) {\r\n    this.instructions = false;\r\n    const food = new Target(x, y, 3);\r\n    let touchedLotus = false;\r\n\r\n    for (const lotus of this.lotuses) {\r\n      if (lotus.isTouched(x, y)) {\r\n        touchedLotus = true;\r\n        this.addFish();\r\n        this.var += 0.001;\r\n        lotus.triggerBob();\r\n        this.ripple(lotus.x + lotus.size / 2, lotus.baseY + lotus.size / 2, 30);\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!touchedLotus) {\r\n      if (this.foods.length < this.maxFood) {\r\n        this.foods.push(food);\r\n      } else {\r\n        this.foods.shift();\r\n        this.foods.push(food);\r\n      }\r\n      for (let fish of this.fish) fish.foodNotify(food);\r\n    }\r\n  }\r\n\r\n  addFish() {\r\n    let hov = Math.random() * 2;\r\n    let x, y, dir;\r\n    if (hov > 1) {\r\n      y = this.height / 2;\r\n      hov = Math.random() * 2;\r\n      if (hov > 1) {\r\n        x = -50;\r\n        dir = 0.0001;\r\n      } else {\r\n        x = 50 + this.width;\r\n        dir = Math.PI;\r\n      }\r\n    } else {\r\n      x = this.width / 2;\r\n      if (hov > 1) {\r\n        y = -100;\r\n        dir = Math.PI / 2;\r\n      } else {\r\n        y = this.height + 100;\r\n        dir = (Math.PI / 2) * 3;\r\n      }\r\n    }\r\n\r\n    this.fish.push(\r\n      new Fish({\r\n        mass: 35 + Math.sqrt(Math.random() * 10000) + this.var,\r\n        x: x,\r\n        y: y,\r\n        pond: this,\r\n        direction: dir,\r\n      })\r\n    );\r\n  }\r\n\r\n  getLetterLotusPositions() {\r\n    const spacing = this.vw * 4;\r\n    const startX = this.vw * 1.2;\r\n    const startY = this.height - this.vh * 66;\r\n    const points = [];\r\n\r\n    const grid = [\r\n      [\r\n        [1, 0],\r\n        [0, 1],\r\n        [2, 1],\r\n        [0, 2],\r\n        [1, 2],\r\n        [2, 2],\r\n        [0, 3],\r\n        [2, 3],\r\n        [0, 4],\r\n        [2, 4],\r\n      ],\r\n      [\r\n        [0, 0],\r\n        [0, 1],\r\n        [0, 2],\r\n        [0, 3],\r\n        [1, 4],\r\n        [2, 4],\r\n      ],\r\n      [\r\n        [0, 0],\r\n        [0, 1],\r\n        [0, 2],\r\n        [0, 3],\r\n        [0, 4],\r\n        [1, 1],\r\n        [2, 2],\r\n        [3, 1],\r\n        [4, 0],\r\n        [4, 1],\r\n        [4, 2],\r\n        [4, 3],\r\n        [4, 4],\r\n      ],\r\n      [\r\n        [1, 0],\r\n        [0, 1],\r\n        [2, 1],\r\n        [0, 2],\r\n        [1, 2],\r\n        [2, 2],\r\n        [0, 3],\r\n        [2, 3],\r\n        [0, 4],\r\n        [2, 4],\r\n      ],\r\n    ];\r\n\r\n    let offsetX = startX;\r\n    let offsetY = startY;\r\n\r\n    for (let g of grid) {\r\n      for (let [gx, gy] of g) {\r\n        points.push({\r\n          x: offsetX + gx * spacing,\r\n          y: offsetY + gy * spacing,\r\n        });\r\n      }\r\n      offsetX += spacing * 6;\r\n    }\r\n    return points;\r\n  }\r\n\r\n  ripple(x, y, size) {\r\n    this.ripples.push(new Ripple(x, y, size, this, this.ripples.length));\r\n  }\r\n\r\n  getClosestFood(x, y) {\r\n    if (this.foods.length === 0) return null;\r\n    let closest = this.foods[0];\r\n    for (let i = 1; i < this.foods.length; i++) {\r\n      if (this.foods[i].getDistance(x, y) < closest.getDistance(x, y)) {\r\n        closest = this.foods[i];\r\n      }\r\n    }\r\n    return closest;\r\n  }\r\n\r\n  getSpot() {\r\n    return this.spots[Math.floor(Math.random() * this.spots.length)];\r\n  }\r\n\r\n  bite(x, y, radius, fish) {\r\n    for (let i = 0; i < this.foods.length; i++) {\r\n      if (this.foods[i].getDistance(x, y) < radius + 10) {\r\n        this.foods[i].eaten(fish);\r\n        this.foods.splice(i, 1);\r\n        i--;\r\n      }\r\n    }\r\n    if (fish.target && fish.target.value === 0) {\r\n      for (let spot of this.spots) {\r\n        if (spot.getDistance(x, y) < 200) {\r\n          spot.eaten(fish);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = FishPond;\r\n\n\n//# sourceURL=webpack://happy-birthday/./lib/fish_pond.js?\n}");

/***/ }),

/***/ "./lib/lotus.js":
/*!**********************!*\
  !*** ./lib/lotus.js ***!
  \**********************/
/***/ ((module) => {

eval("{class Lotus {\r\n  constructor(x, y, size, image, pond) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.baseY = y;\r\n    this.size = size;\r\n    this.image = image;\r\n    this.pond = pond;\r\n\r\n    this.bobBoost = 0; // for click bounce effect\r\n    this.bobTime = Math.random() * 100;\r\n    this.driftOffset = Math.random() * 1000;\r\n    this.driftSpeed = 0.01 + Math.random() * 0.02;\r\n\r\n    this.xInit = x;\r\n    this.yInit = y;\r\n    this.targetX = x;\r\n    this.targetY = y;\r\n  }\r\n\r\n  render(ctx) {\r\n    this.bobTime += 0.03;\r\n\r\n    // floating + bounce effect\r\n    const floatOffset = Math.sin(this.bobTime) * 5;\r\n    const boostOffset = Math.sin(this.bobBoost * Math.PI) * 10;\r\n    const offsetY = floatOffset - boostOffset;\r\n\r\n    // drifting left/right\r\n    this.driftOffset += this.driftSpeed;\r\n    const driftX = Math.sin(this.driftOffset) * 5;\r\n\r\n    // draw the image\r\n    if (this.image.complete) {\r\n      ctx.drawImage(\r\n        this.image,\r\n        this.x + driftX,\r\n        this.baseY + offsetY,\r\n        this.size,\r\n        this.size\r\n      );\r\n    }\r\n\r\n    // decay the bob\r\n    if (this.bobBoost > 0) {\r\n      this.bobBoost -= 0.05;\r\n      if (this.bobBoost < 0) this.bobBoost = 0;\r\n    }\r\n\r\n    // animate formation or dispersal\r\n    if (this.pond.lotusFormationMode) {\r\n      this.x += (this.xInit - this.x) * 0.1;\r\n      this.baseY += (this.yInit - this.baseY) * 0.1;\r\n    } else {\r\n      this.x += (this.targetX - this.x) * 0.02;\r\n      this.baseY += (this.targetY - this.baseY) * 0.02;\r\n    }\r\n  }\r\n\r\n  isTouched(x, y) {\r\n    return (\r\n      x >= this.x &&\r\n      x <= this.x + this.size &&\r\n      y >= this.baseY &&\r\n      y <= this.baseY + this.size\r\n    );\r\n  }\r\n\r\n  triggerBob() {\r\n    this.bobBoost = 1;\r\n  }\r\n}\r\n\r\nmodule.exports = Lotus;\r\n\n\n//# sourceURL=webpack://happy-birthday/./lib/lotus.js?\n}");

/***/ }),

/***/ "./lib/main.js":
/*!*********************!*\
  !*** ./lib/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("{const FishPond = __webpack_require__(/*! ./fish_pond.js */ \"./lib/fish_pond.js\");\r\n\r\nconst canvas = document.getElementsByTagName(\"canvas\")[0];\r\nlet pond = new FishPond(window);\r\n\r\nfunction clickCanvas(e) {\r\n    const x = e.clientX - canvas.offsetLeft;\r\n    const y = e.clientY - canvas.offsetTop;\r\n    pond.click(x,y);\r\n}\r\n\r\ncanvas.addEventListener('click', clickCanvas);\r\npond.start(canvas);\r\n\n\n//# sourceURL=webpack://happy-birthday/./lib/main.js?\n}");

/***/ }),

/***/ "./lib/ripple.js":
/*!***********************!*\
  !*** ./lib/ripple.js ***!
  \***********************/
/***/ ((module) => {

eval("{class Ripple{\r\n  constructor(x,y,size,pond,index){\r\n    this.x = x;\r\n    this.y = y;\r\n    this.size = size;\r\n    this.pond = pond;\r\n    this.index = index;\r\n    this.opacity=1;\r\n    this.ops=this.opacity/size/4;\r\n    this.lineWidth = 1;\r\n    this.radius=1;\r\n  }\r\n  render(ctx){\r\n    ctx.strokeStyle=`rgba(235,235,235,${this.opacity})`;\r\n    ctx.lineWidth = this.lineWidth;\r\n\r\n    ctx.beginPath();\r\n    ctx.arc(this.x, this.y,\r\n      3*Math.sqrt(this.radius),\r\n      0, 2 * Math.PI, true);\r\n    ctx.stroke();\r\n    ctx.closePath();\r\n\r\n    if(this.opacity < 0)\r\n      this.pond.ripples.splice(this.indx,1);\r\n    this.opacity -= this.ops;\r\n    this.lineWidth+=.1;\r\n    this.radius++;\r\n  }\r\n}\r\n\r\nmodule.exports = Ripple;\r\n\n\n//# sourceURL=webpack://happy-birthday/./lib/ripple.js?\n}");

/***/ }),

/***/ "./lib/target.js":
/*!***********************!*\
  !*** ./lib/target.js ***!
  \***********************/
/***/ ((module) => {

eval("{class Target{\r\n  constructor(x,y,value,nextSpot){\r\n    this.value=value;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.nextSpot=nextSpot;\r\n    this.colors = [\r\n      [212, 168, 72],\r\n      [123, 101, 57],\r\n      [212, 112, 46],\r\n      [169, 155, 60]\r\n    ];\r\n    this.baseColor=Math.floor(Math.random()*this.colors.length);\r\n    this.baseColor=`rgb(${this.colors[this.baseColor][0]},${this.colors[this.baseColor][1]},${this.colors[this.baseColor][2]})`;\r\n  }\r\n  getDistance(x,y){\r\n    const xdif = this.x-x;\r\n    const ydif = this.y-y;\r\n    return Math.sqrt(xdif*xdif+ydif*ydif);\r\n  }\r\n  eaten(fish){\r\n    if(this.value===0 && this == fish.target)\r\n      fish.target=this.nextSpot;\r\n    else if(this.value > 0){\r\n      fish.target=null;\r\n      fish.feed(this.value);\r\n      this.value=-1;\r\n    }\r\n\r\n  }\r\n  render(ctx){\r\n    if(this.value>0){\r\n      ctx.fillStyle=this.baseColor;\r\n\r\n      ctx.beginPath();\r\n      ctx.arc(this.x, this.y,\r\n        3,\r\n        0, 2 * Math.PI, true);\r\n      ctx.fill();\r\n      ctx.closePath();\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Target;\r\n\n\n//# sourceURL=webpack://happy-birthday/./lib/target.js?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/main.js");
/******/ 	
/******/ })()
;